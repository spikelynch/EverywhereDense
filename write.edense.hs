-- 

import Data.Char (ord, isLower, isUpper, toLower, isLetter, toUpper)
import Data.List (intercalate)
import System.Random (randomRIO)
import EverywhereDense


antlist = geometry_a


antlist_i :: Char -> [ String ]
antlist_i c = case isUpper c of
               True -> antlist $ toLower c
               False -> antlist c

expchar :: Char -> IO String
expchar c = do
  words <- return (antlist_i c)
  case null words of
    True -> return ("" :: String )
    False -> do
              n <- randrange words
              return $ words !! n

randrange :: [ a ] -> IO Int
randrange list = randomRIO (0, (length list) -1)


expWord :: String -> IO [ String ]
expWord = mapM expchar 

expSentence :: [ String ] -> IO [ [ String ] ]
expSentence = mapM expWord

expParagraph :: [ [ String ] ] -> IO [ [ [ String ] ] ]
expParagraph = mapM expSentence

expChapter :: [ [ [ String ] ] ] -> IO [ [ [ [ String ] ] ] ]
expChapter = mapM expParagraph

expSection :: [ [ [ [ String ] ] ] ] -> IO [ [ [ [ [ String ] ] ] ] ]
expSection = mapM expChapter


laySentence :: [ String ] -> String
laySentence sentence = case length words of
                         0 -> ""
                         otherwise -> (intercalate " " words) ++ "."
    where words = capfirst $ filter ( not . null ) sentence
          
capitalise [] = []
capitalise (c:cs) = (toUpper c):cs 

capfirst [] = []
capfirst (w:ws) = (capitalise w):ws

layParagraph :: [ [ String ] ] -> String
layParagraph paragraph = (intercalate " " sentences) ++ "\n\n"
    where sentences = filter ( not . null ) $ map laySentence paragraph

layChapter :: [ [ [ String ] ] ] -> String
layChapter chapter = (heading 3 header) ++ "\n\n" ++ (concat body) ++ "\n\n"
    where (header, ps) = chapterHeader chapter 
          body = map layParagraph ps

chapterHeader ((s:ss):ps) = (s, ss:ps)
chapterHeader _           = ([], [])


laySection :: [ [ [ [ String ] ] ] ] -> String
laySection section = (heading 2 header) ++ "\n\n" ++ (concat body)
    where (header, cs) = sectionHeader section
          body = map layChapter cs
       

sectionHeader (((s:ss):ps):cs) = (s, (ss:ps):cs)
sectionHeader _                = ([], [])

layNovel :: [ [ [ [ [ String ] ] ] ] ] -> String
layNovel novel = titlepage ++ "\n\n" ++ body
    where titlepage = "EVERYWHERE DENSE\n================\n\na generated novel\n\n"
          body = concatMap laySection novel


heading :: Int -> [ String ] -> String
heading i s = prefix ++ " " ++ (map toUpper sentence) ++ "\n\n"
    where sentence = intercalate " " $ filter ( not . null ) s
          prefix = replicate i '#'




outputFile = "everywhere.dense.md" :: FilePath

initStr = "Everywhere Dense is a novel generated by the principle of recursive acronym expansion, in which this sentence is repeatedly interpolated with random words." :: String



main :: IO ()
main = do 
  sentence <- expWord initStr
  putStrLn $ show $ length sentence
  paragraph <- expSentence sentence
  putStrLn $ show $ length paragraph
  chapter <- expParagraph paragraph
  putStrLn $ show $ length chapter
  section <- expChapter chapter
  putStrLn $ show $ length section
  novel <- expSection section
  putStrLn $ show $ length novel
  writeFile outputFile $ layNovel novel
